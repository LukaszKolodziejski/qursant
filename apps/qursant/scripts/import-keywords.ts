/*
  Script: import-keywords.ts
  Purpose: Parse config/keywords.csv into apps/qursant/src/data/keywords.ts and validate target URLs exist.
  Run: node -r @swc-node/register apps/qursant/scripts/import-keywords.ts
*/

import * as fs from 'fs';
import * as path from 'path';

type KeywordRow = {
  keyword: string;
  intent: string;
  cluster: string;
  target_url: string;
  notes?: string;
};

const ROOT = path.resolve(__dirname, '../../..');
const APP_SRC = path.join(ROOT, 'apps/qursant/src');
const APP_PAGES_DIR = path.join(APP_SRC, 'app');
const CSV_PATH = path.join(ROOT, 'config/keywords.csv');
const OUTPUT_TS = path.join(APP_SRC, 'data/keywords.ts');

function readCsvFile(filePath: string): string {
  if (!fs.existsSync(filePath)) {
    throw new Error(`CSV not found: ${filePath}`);
  }
  return fs.readFileSync(filePath, 'utf8');
}

function parseCsv(csv: string): KeywordRow[] {
  const lines = csv
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  if (lines.length === 0) return [];

  const header = lines[0].split(',').map((h) => h.trim().replace(/^"|"$/g, ''));
  const expected = ['keyword', 'intent', 'cluster', 'target_url', 'notes'];
  const headerOk = expected.every((col) => header.includes(col));
  if (!headerOk) {
    throw new Error(
      `Invalid CSV header. Expected columns: ${expected.join(
        ', '
      )}. Got: ${header.join(', ')}`
    );
  }

  const rows: KeywordRow[] = [];
  for (let i = 1; i < lines.length; i++) {
    const fields = splitCsvLine(lines[i]);
    const record: Record<string, string> = {};
    header.forEach((col, idx) => {
      record[col] = (fields[idx] ?? '').trim();
    });
    const row: KeywordRow = {
      keyword: record.keyword?.replace(/^"|"$/g, ''),
      intent: record.intent?.replace(/^"|"$/g, ''),
      cluster: record.cluster?.replace(/^"|"$/g, ''),
      target_url: record.target_url?.replace(/^"|"$/g, ''),
      notes: record.notes?.replace(/^"|"$/g, '') || undefined,
    };
    if (!row.keyword || !row.intent || !row.cluster || !row.target_url) {
      // skip incomplete lines but warn
      console.warn(`Skipping incomplete row at line ${i + 1}`);
      continue;
    }
    // normalize path (no trailing slash except root)
    if (row.target_url !== '/' && row.target_url.endsWith('/')) {
      row.target_url = row.target_url.replace(/\/+$/, '');
    }
    rows.push(row);
  }
  return rows;
}

function splitCsvLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') {
      // toggle quotes or escape double quote
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (ch === ',' && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += ch;
    }
  }
  result.push(current);
  return result;
}

function collectAvailableRoutes(): string[] {
  const routes: string[] = [];
  function walk(dir: string, relFromApp: string) {
    const items = fs.readdirSync(dir, { withFileTypes: true });
    for (const item of items) {
      const full = path.join(dir, item.name);
      const rel = path.join(relFromApp, item.name);
      if (item.isDirectory()) {
        walk(full, rel);
      } else if (item.isFile() && item.name === 'page.tsx') {
        // translate to route
        const parentDir = path.dirname(rel);
        const route =
          parentDir === '.' ? '/' : '/' + parentDir.replace(/\\/g, '/');
        routes.push(route);
      }
    }
  }
  walk(APP_PAGES_DIR, '');
  // unique & sorted
  return Array.from(new Set(routes)).sort();
}

function writeOutputTs(rows: KeywordRow[], availableRoutes: string[]) {
  const outDir = path.dirname(OUTPUT_TS);
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
  const content =
    `// AUTO-GENERATED FILE. Do not edit manually.\n` +
    `// Generated by scripts/import-keywords.ts\n` +
    `export type KeywordEntry = { keyword: string; intent: string; cluster: string; target_url: string; notes?: string };\n` +
    `export const keywordEntries: KeywordEntry[] = ${JSON.stringify(
      rows,
      null,
      2
    )} as const;\n` +
    `export const availableRoutes: string[] = ${JSON.stringify(
      availableRoutes,
      null,
      2
    )} as const;\n` +
    `\n` +
    `// Compatibility exports for dev panel (/seo/keywords)\n` +
    `export type KeywordRecord = {\n` +
    `  keyword: string;\n` +
    `  intent: string;\n` +
    `  cluster: string;\n` +
    `  targetUrl: string;\n` +
    `  notes?: string;\n` +
    `  volume?: number;\n` +
    `  kd?: number;\n` +
    `  cpc_pln?: number;\n` +
    `  trend_12m?: string;\n` +
    `  serpTypes?: string;\n` +
    `  priority?: 'HIGH' | 'MEDIUM' | 'LOW';\n` +
    `};\n` +
    `export const keywords: KeywordRecord[] = keywordEntries.map((k) => ({\n` +
    `  keyword: k.keyword,\n` +
    `  intent: k.intent,\n` +
    `  cluster: k.cluster,\n` +
    `  targetUrl: k.target_url,\n` +
    `  notes: k.notes,\n` +
    `  serpTypes: k.notes,\n` +
    `  priority: 'MEDIUM',\n` +
    `}));\n` +
    `export function getAllClusters(): string[] {\n` +
    `  return Array.from(new Set(keywords.map((k) => k.cluster))).sort();\n` +
    `}\n` +
    `export function getAllIntents(): string[] {\n` +
    `  return Array.from(new Set(keywords.map((k) => k.intent))).sort();\n` +
    `}\n`;
  fs.writeFileSync(OUTPUT_TS, content, 'utf8');
  console.log(
    `Wrote ${OUTPUT_TS} with ${rows.length} rows and ${availableRoutes.length} routes.`
  );
}

function validateTargets(rows: KeywordRow[], availableRoutes: string[]) {
  const existing = new Set(availableRoutes);
  const invalid = rows.filter((r) => !existing.has(r.target_url));
  return invalid;
}

function validateDuplicateTargetsByIntent(rows: KeywordRow[]) {
  const seen = new Map<string, KeywordRow[]>();
  for (const r of rows) {
    const key = `${r.intent}||${r.target_url}`;
    const list = seen.get(key) ?? [];
    list.push(r);
    seen.set(key, list);
  }
  const duplicates: {
    intent: string;
    target_url: string;
    count: number;
    keywords: string[];
  }[] = [];
  for (const [key, list] of seen.entries()) {
    if (list.length > 1) {
      const [intent, target_url] = key.split('||');
      duplicates.push({
        intent,
        target_url,
        count: list.length,
        keywords: list.map((r) => r.keyword),
      });
    }
  }
  return duplicates;
}

function main() {
  const csv = readCsvFile(CSV_PATH);
  const rows = parseCsv(csv);
  const routes = collectAvailableRoutes();
  const missingTargets = validateTargets(rows, routes);
  const duplicates = validateDuplicateTargetsByIntent(rows);

  const isValidateOnly = process.env.VALIDATE_ONLY === '1';
  let hasErrors = false;
  if (missingTargets.length > 0) {
    hasErrors = true;
    const list = missingTargets
      .map((r) => `${r.intent} | ${r.keyword} -> ${r.target_url}`)
      .join('\n');
    console.error(`ERROR: target_url nie istnieją jako strony:\n${list}`);
  }
  if (duplicates.length > 0) {
    hasErrors = true;
    const list = duplicates
      .map(
        (d) =>
          `${d.intent} | ${d.target_url} (duplikaty: ${
            d.count
          }) <- [${d.keywords.join(', ')}]`
      )
      .join('\n');
    console.error(
      `ERROR: Wykryto duplikaty target_url w obrębie tej samej intencji:\n${list}`
    );
  }

  if (isValidateOnly) {
    if (hasErrors) process.exit(1);
    console.log('Walidacja keywords.csv: OK');
    return;
  }

  writeOutputTs(rows, routes);
}

main();
